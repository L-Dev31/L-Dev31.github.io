{
    "posts": [
      {
        "id": 1,
        "title": "Understanding Savestates",
        "date": "March 28, 2025",
        "excerpt": "Why They Shouldn't Replace In-Game Saves",
        "category": "technical",
        "author": {
          "name": "PabloMK7",
          "avatar": "https://avatars.githubusercontent.com/u/10946643?v=4"
        },
        "image": "news.png",
        "content": "<p>It's been a week since Azahar's first stable release, and one common issue we've heard from our users is that save data has inexplicably disappeared after updating. While we initially thought this could be a result of not selecting the correct user folder or using out-of-region game backups, we now believe these reports stem from a long-standing misconception that has affected users since the early Citra days.</p><p>Let's talk about savestates.</p><h2>What are savestates</h2><p>Savestates are a feature in Azahar (originally from Citra) that let you create a snapshot of the game's current state, so that later you can resume exactly in the same place where you left off. This makes it possible to rewind time if you find yourself in a tough spot, such as missing a critical attack in a boss fight or accidentally using a rare item.</p><p>While savestates are really useful for short-term saving, they should NEVER EVER be used as a replacement for regular in-game saves. Why?</p><h2>How do savestates work in Azahar</h2><p>On emulators for older retro consoles like the SNES or N64, savestates work by simply dumping the entire system memory along with the (very small) hardware state. The 3DS however is a much more complex system, running a full operating system. It gets even trickier when you consider that the OS itself isn't directly emulated in Azahar, instead it is high-level emulated (HLE). This means that Azahar intercepts the game's OS calls and simulates the expected responses, instead of having an actual 3DS OS running in the background.</p><p>Because of this, saving and restoring a 3DS savestate requires much more than just memory dumps. Every variable, pointer, and structure of the simulated OS must be properly saved to ensure it can be accurately restored later. If you take a look at the codebase, you'll see just how many serialize functions are scattered throughout, it's a clear sign of how much effort goes into making savestates work properly.</p><h2>Why you should not use savestates for long term saving</h2><p>The simulated 3DS OS is still incomplete, and whenever we update it, we often need to change which data is stored in savestates. When that happens, savestates from older versions of Azahar become incompatible with newer versions, as the stored data in the savestate no longer matches what Azahar expects.</p><p>Supporting older savestates with extra compatibility code might seem like a solution, but it would quickly turn the emulator's codebase into a mess as we would need to add supporting code for every, single, past version of the emulator. Instead, we choose to keep things clean and efficient, after all, savestates are meant for short-term saving, not long-term storage.</p><p>This problem may have become more prominent lately, as there hasn't been many updates to the core of Lime3DS in a very long time. Only when we started working in Azahar is when we had to add extra data to savestates to support all the new features, breaking compatibility.</p><h2>What should I do if I lost my progress?</h2><p>The only way to recover old savestates is to temporarily downgrade to the emulator version in which the savestate was created. Once downgraded, you can load the savestate and save your progress properly using the in-game save system. After that, you can upgrade to the latest emulator version and continue playing from the in-game save file.</p><h2>Conclusion</h2><p>As a conclusion, We would like to remind everyone that, to avoid losing progress in the future, you should always rely on in-game saves rather than savestates. While savestates are a useful tool for short-term convenience, only in-game saves ensure long-term compatibility across emulator updates.</p>"
      },
      {
        "id": 2,
        "title": "Citra: 1 Year On",
        "date": "March 4, 2025",
        "excerpt": "One final look back.",
        "category": "news",
        "author": {
          "name": "OpenSauce",
          "avatar": "https://avatars.githubusercontent.com/u/48618519?v=4"
        },
        "image": "https://azahar-emu.org/resources/blogs/one-year-citra-takedown/kirby_after.jpg",
        "content": "<p>Well, today's the day. It has been a whole year since Citra was taken down. It really doesn't feel like it's been that long, does it?</p><p>To commemorate this anniversary, I wanted to take one last look back on Citra's takedown and the impact it left on 3DS emulation.</p><p>Many of us will remember how we felt that day as we lost a major cornerstone of video-game preservation. It was most likely an ordinary day like any other, but just like that when nobody expected it, Citra was suddenly gone, forever replaced with a 3 paragraph obituary on their website. It was as shocking as it was disheartening, with years and work from hundreds of people disappearing in an instant.</p><p>Some people saw this and felt defeated, but others decided to take up the mantle and act to continue Citra's legacy. Several Citra forks showed up in the aftermath, each of them united in the shared spirit of continuing what Citra started.</p><p>In spite of the circumstances, innovation continued, and as the 3DS emulation scene adjusted, momentum slowly began to pick up again. As a new generation of passionate users took on the mantle of development where Citra no longer could, improvements to the emulator continued flowing. In particular PabloMK7's Artic Base was a significant development which took a whole new spin on what video-game console emulation could be, and proved that there was still room to grow in the 3DS emulation scene.</p><p>And now, one year on, we're on the verge of a new era of Citra development. With the joining of two major forks that originally spawned from Citra's shutdown, the future of this codebase once again looks bright. Before we move on however, there is one last piece of Citra's legacy which we would like to share with you.</p><p>Shortly before Citra was taken down, a progress was in the midst of being written by PabloMK7, GPUCode and others, and just as it was ready to release, March 4th happened. Because of this, the final Citra progress report never saw the light of day.</p><p>That's why today, to both commemorate and give a final send-off to Citra, we thought we should release this progress report as the final piece of content ever officially produced by Citra. We hope you enjoy reading it, but be aware that it is a bit technical!</p><h2>Citra Progress Report 2023 H2</h2><p>Written by GPUCode, PabloMK7, et al.<br>February 20, 2024</p><p>Welcome readers, and happy (belated) new year! We hope you all had a brilliant 2023, just as we did. The past year saw a boom in development across all areas of 3DS emulation for Citra, which we're super thrilled to share. From networking changes, to HOME Menu compatibility updates, to graphics enhancements, we've got it all! So strap in - and get ready for the very best of what we cooked up in the latter half of the last year.</p><h3>Contents</h3><ul><li>Emulation</li><li>Networking</li><li>Amiibo</li><li>Graphics</li><li>Audio</li><li>Conclusion</li></ul><h3>Emulation</h3><p>There has been a lot of progress as of late in achieving full system emulation. Just last year, HOME Menu emulation became a reality, unlocking a whole new world of applications that needed care and attention. The work never ends, does it?</p><p>Last time we mentioned that, while launching games from the HOME Menu worked, suspending or re-launching titles was generally hit-or-miss, with some titles crashing outright. This was because Citra was not cleaning up kernel objects correctly on process shutdown. Games, deservedly, expect a clean environment when they are launched and any operating system worth its salt is responsible for that. A process in HorizonOS, the operating system that runs on the Nintendo 3DS, is conceptually quite similar to the concept of a process in modern operating systems. It has its own address space, child threads, and is responsible for babysitting any kernel objects created by those threads.</p><p>Given that we are talking about this in a progress report, it's safe to say that's a problem no more! Steveice10 turned a few nobs here and there and made sure that exiting a kernel process releases all the memory it owns and stops its child threads as well.</p><p>Steveice10 continued with the HOME Menu streak, implementing some additional service commands in the APT module and adding a power button to complete another crucial part of HOME Menu functionality: powering down the console. Whenever the HOME Menu is launched, pressing V on the keyboard will trigger the familiar screen.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/power_button.jpg' alt='Power button screen'><p>Same as pressing the power button on the 3DS!</p><p>While this might be the only user facing change of Steveice10's APT work, there's still more that was done. Symbol discoveries from Fire Emblem Fates gave Steveice10 the opportunity to rename a bunch of methods to match the official function names used by Nintendo. New 3DS capabilities were also hooked up to the kernel so that APT can more accurately report the capabilities of the emulated console variant.</p><p>Naming things is hard, especially when the thing you are naming isn't well understood. However, some retail games may contain, by accident, valuable debug information, including symbolic for services and the OS. These discoveries always help better clarify the service interface and can especially help when documenting unexplored areas. To nobody's surprise, the symbols from the same game also prompted developer SachinVin to adjust member variable names in the DSP service in a similar manner.</p><p>Speaking of the devil, uh- the DSP, Steveice10 stubbed binary requests SaveState and LoadState that are used by the AAC decoder to implement DSP sleep and wake behaviour accordingly. With this change, games like Pokémon X and Tales of the Abyss can now suspend to the HOME Menu without crashing, with the catch being that the game audio is lost as this isn't a full implementation. We have started taking steps to improve our audio emulation, something that will take time and a lot of effort, but we think will be worth it in the end.</p><p>No more crashing</p><p>Aside from tackling crashes, Steveice10 also improved the stability of the HOME Menu by adjusting various services to use correct session limits, stubbing numerous service calls used by the HOME Menu and fixing incorrect logic in the microphone service that was responsible for a random freeze that could happen in the HOME Menu, most easily reproduced by pausing emulation for a while and resuming.</p><p>A different problem that wasn't strictly a regression, but more of an annoyance, was centred around configuration blocks. During our efforts to make the HOME Menu functional, the list of configuration blocks was amended many times according to the needs of the HOME Menu and the effort to bring Citra up to date with the new configuration blocks noted on 3dbrew.</p><p>However, these changes required users to manually remove their config save file for the new Citra version to regenerate it appropriately. So, users upgrading from old Citra versions would still experience the same crashes all over again. To end this confusion, Steveice10 reworked the configuration block system to create missing blocks on the fly. Essentially, Citra will upgrade the config save for you automatically. Neat!</p><p>Finally, Steveice10 optimised the Y2R decoding process, which shaved about 0.1ms of decoding time on a modern desktop computer and worked around a bug that prevented Danball Senki Wars from booting. The game, possibly due to a bug in its own code, was calling a service function Y2R_StartConversion multiple times on the same data. Citra did not account for this and the function would work on invalid data the second time around. Yet more evidence that the creativity of game devs is truly endless, and this certainly will not be the last of such cases.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/looks_like_snow.jpg' alt='Snow effect in game'><p>That looks like snow alright</p><h3>Networking</h3><p>One cannot achieve full system emulation without looking at the network features of the 3DS.</p><p>On this beautiful console, network functionality is served by three system services. The first and most important one, named SOC, provides a raw socket interface pretty similar to the POSIX standard - in which sockets are endpoints of communication between two applications over the network and are the foundation of the modern internet. The second one, named SSL, provides a layer of security over sockets. And finally, the last one, named HTTPC, allows games to perform HTTP requests without having to worry about implementing their own HTTP details.</p><p>As you may have noticed, there is a clear dependency between the three main network related system modules. HTTPC requires SSL to work, in order to be able to serve HTTPS requests, and SSL requires SOC to work, in order to make socket operations possible at all. Side note: the chain of dependencies doesn't end here, as SOC depends on yet another system module, NWM, which implements the Wi-Fi chip driver. However, this is not relevant for Citra, which doesn't emulate the details of the Wi-Fi chip. Luckily for us, the deepest link in the chain, the SOC service, provides an interface pretty similar to the POSIX standard, which is supported natively by most operating systems. This makes fully implementing the SOC service easier... or so we thought... (Windows, I'm totally not looking at you)</p><p>While not covered in previous progress reports, the road into fully implementing the SOC service started back in Q3 2022 thanks to contributor PabloMK7. The first batch of fixes addressed differences in the flags passed to the poll function, among other things, which were causing Windows to return an error and making socket communications impossible. Thanks to this fix, the network functionality of many homebrew apps that used libcurl, and didn't depend on the unimplemented SSL or HTTPC modules, started working!</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/ctgp7_updates.jpg' alt='CTGP-7 updating'><p>CTGP-7 is able to self update</p><p>Long-time Citra developer FearlessTobi also joined in on the network fun, this time setting his sights on the New 3DS browser (SKATER). A CRO (the 3DS equivalent of .dll files) adjustment by Steveice10 was all that it took to make the application boot, but it wouldn't be very functional without the ability to surf the web, would it?</p><p>In order to connect online, the browser talks to the HTTPC service, which is responsible for sending and receiving HTTP requests. While the internet browser doesn't use the HTTPC module to make HTTP requests, it has its own HTTP and SSL stack, it still uses the service to apply other configurations. FearlessTobi implemented some missing service functions which, thankfully, made the browser happy and allowed it to load web pages successfully. Note that with this change, you still cannot watch video content on the browser as that requires the currently unimplemented MVD service.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/skater1.png' alt='3DS browser showing Google'><p>Google on a 13-year-old console? Sign me up!</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/skater2.png' alt='3DS browser showing Citra blog'><p>You can read this progress report... from Citra??</p><p>As you can imagine, with the New 3DS browser fixed up, it was really a matter of time until the Old 3DS browser (SPIDER) got the same treatment. First time contributor and Pretendo Network developer DaniElectra jumped in by fixing a small error in FearlessTobi's contribution and stubbing GetConnectingProxyEnable, thus bringing its older sibling up to speed.</p><p>Now, coming back to online connectivity, PabloMK7 was facing a small issue with some newer games that had updated network libraries. One of those games was Animal Crossing: New Leaf. While it was possible for a person on Citra to visit a town hosted by a 3DS (as shown in the following post), it was only possible for a person on a 3DS to visit a town hosted by Citra if both devices were inside the same network.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/mr_resetti.jpg' alt='Animal Crossing error'><p>Mr. Resetti, I'd appreciate it if you were more descriptive...</p><p>After several weeks of research, dumping network traffic, and getting assistance from developer m4xw, the issue was tracked down to a missing implementation detail in the SOC module. It turned out the game was setting the packet TTL (time to live) value to 0. This value tells routers in the network how many more \"jumps\" a packet can do before being dropped, and in most operating systems, setting the TTL to 0 simply disables it from jumping to more than one router (hence why the issue didn't happen if both devices were on the same network) However, on the 3DS, the value of 0 has a special meaning: \"set the TTL to the default value: 64\". After this detail was fixed, the game started working perfectly online.</p><p>At the same time, PabloMK7 discovered a major inaccuracy in the SOC service. But to describe it, we have to talk a bit more about sockets. Sockets have two ways of operation: blocking and non-blocking. Those modes tell the operating system how the socket should behave when a read operation is performed, but with no data available. In blocking mode, the program execution is paused until data is received, at which point execution is resumed automatically. In non-blocking mode, the read function immediately returns with an error indicating that no data was received and that the operation would block (EWOULDBLOCK).</p><p>It was noticed that the way sockets were handled changed over time. In older games, the code was constantly checking for incoming data using a combination of poll and non-blocking sockets, but in newer games, it spawned a new thread that would simply try to receive data on a blocking socket. If there was no data available, this would cause this new thread to block, but it didn't matter as the rest of the game threads can move on and do other things in the meantime (such as sending data through the socket). Once the blocking socket receives some data, the network thread is unblocked and the data is processed according to the game's needs.</p><p>However, this pattern presents a problem in Citra: we don't have real multithread support! Instead of having an emulation thread per game thread, a single emulation thread is used that periodically switches execution between the game threads, emulating the thread scheduler of the 3DS. This approach has many benefits. It ensures the emulator maintains high timing accuracy with minimal desync, while also making execution deterministic. That means that when launching any particular application, one can expect the emulator to behave the exact same way, timing-wise, on each run, instead of relying on scheduler details of the host operating system. However, this design choice has a weakness: if a game thread performs a blocking operation, it will also block the emulation thread, hanging the entire emulator.</p><p>Solving this issue in Citra requires tapping into making Citra multithreaded, to run each game thread in a dedicated host thread to mimic the way hardware works. However, the benefits of this approach aren't clear aside from this particular weakness,implementing it requires an almost complete kernel rewrite to make it multithread ready and would sacrifice a lot of emulation accuracy.</p><p>Faced with this conundrum, PabloMK7 needed to find a way to offload the socket operations from the main emulation thread without intrusive changes to the existing kernel and service code. His answer was adding a new function, RunAsync, that can execute any blocking code in a separate host thread while putting the requester game thread to sleep. This allows the emulated scheduler to select a new game thread to run so that the game can continue doing work. Eventually, when the blocking code finishes, the game thread is resumed and the received socket data is finally processed, ensuring the service can work correctly when used in such a manner.</p><p>Another applet that received its well-deserved spa treatment is the Friend List applet. While it has been possible to boot it for quite some time by enabling the LLE FRD service module, the HLE implementation was simply lacking too much to boot it. To shrink the gap between implementations, FearlessTobi stubbed several FRD functions to prevent it from crashing. However we still recommend using the LLE service whenever FRD is required until further improvements to the HLE implementation are made.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/make_friends.jpg' alt='Friend List applet'><p>Time to go out and make new friends!</p><p>PabloMK7 later amended FearlessTobi's previous HTTPC work by implementing another large chunk of the HLE service. This entails that many more online applications are able to function correctly. For example, the homebrew file manager FBI (not the one you may be thinking of), can now install remote applications, the Pokémon Sun and Moon demo can communicate with the legality check server, the Internet Browser can check its own version, and more!</p><h3>Amiibo</h3><p>That's right! We've got not one, but two guest celebrity appearances in this article! You might know german77 from his work on the Switch HID service and, of course, amiibo.</p><p>With that in mind, it was a pleasant surprise when he offered to implement amiibo on Citra. After all, amiibo is a common interface and it's well known that the Switch service is quite similar to its 3DS counterpart. So after spending a bit of time reverse engineering the 3DS service, combined with his existing knowledge, the first time contributor added amiibo encryption and appdata that promised to fix all games that had issues with amiibos, an enticing proposition indeed. The new service was also tested against hardware to ensure all was well and good.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/amiibo_tests.jpg' alt='Amiibo hardware testing'><p>Can't escape hardware testing in emulator development</p><p>After the PR was merged, german77 updated the service to use the official names from Nintendo using the symbol discoveries we talked about earlier.</p><p>It's now time to bring in the problem child of the story: Chibi-Robo! Zip Lash. A game of questionable quality, it proved to be quite the stress test for the new amiibo implementation. A user first reported that the game attempted to read the amiibo immediately, not giving them any time to load their dump. german77 promptly addressed the issue by automatically starting adapter communication when games scan for amiibo. But, sadly, this wasn't enough. The next day the same user mentioned that while an amiibo could be selected, after a very short time, the game would give an error message.</p><p>german77 investigated that issue as well and found that Chibi-Robo! Zip Lash has a built-in delay after mounting the amiibo tag to ensure the tag is ready to pull data from. The existing implementation removed the tag too soon, so the game didn't get the chance to read any data from it. For this problem, german77 made it so that the time counter would be reset, given that the tag is constantly being used. This means it would not be removed while the game is actively using it. While at it, he also fixed a few small errors in the service and increased the amiibo detection timeout, which fixed loading amiibo's on Hey! Pikmin.</p><p>While the original PR by german77 required dumping the amiibo secrets separately to a key_retail.bin file to support encrypted Amiibo, this is no longer the case. Thanks to his future-proof GodMode9 key dumping script, Steveice10 removed that limitation by using the existing secrets infrastructure for amiibo encryption. This means that if you followed our new AES key dumping guide to setup the HOME Menu, you are also ready to use your amiibo without any additional setup!</p><p>With the more accurate NFC service implementation, Steveice10 also set his sights on emulating the amiibo settings applet, which is used for first time amiibo registration. To do this, he implemented saving the current framebuffers to specific VRAM locations in the SaveVramSysArea service function of the GSP module and updated the APT framebuffer capture for system applets to use these VRAM locations for capturing.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/amiibo.mp4' alt='Registering an Amiibo'><p>Registering an Amiibo, simple stuff</p><h3>Graphics</h3><p>or the number of ways PICA200 can shoot you in the foot</p><p>Amidst all the shiny new OpenGL features and Vulkan performance improvements, the software renderer tends to get overlooked and only used for brief testing on systems without a dedicated GPU to do all the heavy lifting. Even then, this use case is not quite as relevant these days as Citra can now be used with lavapipe, a mature software rasterizer for the Vulkan API.</p><p>Our software renderer has been crucial to the past and future development of Citra and, thus, a worthwhile piece of code to maintain and evolve. Originally crafted by the now Mikage developer neobrain, it has served as a measure of accuracy for the hardware renderers to match, with lots of GPU features such as shadow mapping first having been tested on it before trickling down to the hardware renders.</p><p>However, most of the its structure had remained the same over the years and differed from the hardware renderers in style. It relied on global state, which made it difficult to eliminate that from other parts of the video_core project, and had different namespace naming conventions compared to the hardware renderers. With these points in mind, GPUCode set out to refactor the software renderer to bring its code closer to the standards of the rest of the codebase nowadays. For the end user not much will change, but the code is tidier, cleaner, and more easily maintainable. Always a plus! Not only that, a performance bottleneck relating to memory access was discovered during this effort, and patched, resulting in a noticeable performance boost when using the software renderer!</p><p>Speaking of performance improvements, GPUCode contributed another change to the software renderer that was strictly aimed to improve performance. By processing scanlines in parallel, using multiple threads, performance has almost been doubled in most cases! Of course, that still doesn't make it full speed, since we are talking about a difference of 1 FPS and 2 FPS, but making better use of the system's resources will prove beneficial for future endeavours.</p><p>As for said future, only one word suffices. \"Full speed software rendering!\". Well... that was four words. But you get the gist! Having a software renderer fast enough to perform at full speed will make testing with it immensely easier and is a challenge in optimization we are willing to take on.</p><p>Continuing on the trend of topics-the-average-user-won't-really-care-but-are-interesting-regardless, the shader interpreter also got some love this time around. Fun fact, up until recently it was used as a fallback for Android devices when using geometry shaders, or for draw calls that failed to get hardware accelerated for whatever reason. However, as you'll find out later in the article, we prepared something special for all you Android users in this regard.</p><p>The first change was implementing a bunch of control flow edge cases and missing instructions, like break and breakc. The aforementioned instructions have actually been in the shader JIT for years, and are used in shaders from games like Steel Diver: Sub Wars and Gunman Clive. There are cases where the shader JIT fails, and using the Interpreter as a means of debugging can be greatly beneficial. Case in point, the aforementioned Steel Diver: Sub Wars.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/steel_divers.jpg' alt='Steel Diver submarine'><p>I wouldn't want to be in that vessel if I were you</p><p>The game suffers from quite a peculiar case of freezing syndrome when a torpedo hits another submarine, with the added benefit that it consumes all the user's RAM before crashing. Great... GPUCode found that the game utilises geometry shaders for this collision animation and that the JIT was failing quite spectacularly in trying to execute them. Switching to the interpreter didn't fare much better, being greeted with multiple warnings about the unimplemented instructions. Taking the time to bring the interpreter up to date ensures the game is now playable with the slower backend. More debugging awaits.</p><p>On that same topic, let's talk about something new. While testing Super Mario 3D Land on macOS, Steveice10 encountered a crash when entering the demo level. The crash would only manifest with hardware shaders disabled which meant that, being an arm64 system, the shader backend in use was the interpreter. After some fiddling around, Steveice10 concluded the game was accessing out of bounds uniforms, which the interpreter had no checks or protections against. It also wasn't the only game that tricked Citra like that either. So an interesting question was raised: what happens when games perform these seemingly invalid reads?</p><p>There is only one source of truth for these questions, the console itself. And that's exactly where Steveice10 started looking. After running a bunch of hardware tests with various configurations and parameters, he managed to replicate the exact way the hardware behaves, improving the accuracy of the interpreter and fixing the crashes in the process. The improvements have also been ported to the GLSL backend and x86 shader JIT so everyone can be happy! With the above out of the way, it's finally time to get into the more fancy graphical fixes.</p><h4>Chapter 1 - or... How colour theory is actually tricky</h4><p>Go! Go! Kokopolo - Harmonious Forest Revenge is a 3DS port of a DSiWare title available exclusively as a 3DS North American physical release. The physical release happened last year on September 16th 2022, cementing it as part of the dying breath of the 3DS ecosystem. Normally games released this late into a console's lifespan tend to be quick cash grabs made with existing engines like Unity, which do work well on Citra. However this case was different, as the game exhibited peculiar discolouration in its tiled graphics that made it quite disorienting to play.</p><p>The problem was also exclusive to the hardware renderers, with the software renderer having correct output, albeit at unplayable frame rates. This fact made GPUCode confident that it wouldn't be hard to track down the issue by figuring out which part of the rendering pipeline was causing the divergent pixel values. And this hypothesis was indeed correct! The issue was quickly found to be from the lighting LUT sampling helpers, where the coordinate to sample from was just a few pixels off compared to the software implementation. These LUTs are simple buffers used by the fixed function lighting unit for its various operation, yet it appears the game is abusing them as a sort of colour palette. This means that even the tiniest differences in sampling can cause incorrect colours to be used. Adjusting the hardware renderers to match the software behaviour was enough to correct all the rendering problems in this game and others, such as 3D Fantasy Zone II.</p><div class='image-comparison'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/kokopolo_before.jpg' alt='Before fix'><p>Before</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/kokopolo_after.jpg' alt='After fix'></div><p>After</p><div class='image-comparison'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/fantasy_before.jpg' alt='Before fix'><p>Before</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/fantasy_after.jpg' alt='After fix'></div><p>After</p><p>We mentioned before how useful having a software renderer can be for fixing graphical bugs and we hope the previous case shed some light into the why. But just in case, let's go over another related bugfix.</p><p>After refactoring the software renderer, GPUCode experienced every developer's worst fear... a regression!! The game in question was Kirby's Blowout Blast, where the sky lost its proper colour and became grey instead of blue. The hardware renderers have had this problem for years, but the software renderer was unaffected up until this change. Treating this as an opportunity to also tackle the hardware renderer problems, GPUCode sifted through the pull request changes to pinpoint what went wrong. And the problem was... an uninitialized variable? You heard that right, zero-initialising a vector variable (combiner_output) broke the game.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/combiner_ruin.jpg' alt='Broken Kirby sky'><p>You ruined everything!</p><p>To explain how this is possible, we need a quick introduction to TEV, the system the 3DS uses to render graphics on the screen - even with the lack of pixel shaders. The Texture EnVironment consists of 6 stages of colour and alpha combining. Colour combiners take three input colour values from some source (e.g. interpolated vertex colour, texture colour, previous stage, etc), perform some very simple operations on each of them (e.g inversion) and then calculate the output colour by combining them with some basic arithmetic (e.g addition, multiplication, lerping). Alpha combiners can be configured separately but work in the same manner.</p><p>The important bit here is that any TEV stage can use the output of the previous stage as its input. Kirby's Blowout Blast was multiplying the sky colour with the previous stage result to figure out the final colour... in the first stage. How do you get the previous stage colour, when there is no previous stage?!</p><p>By leaving the vector that holds the output of the current TEV stage uninitialized, holding a possibly non-zero undetermined value, it was accidentally preserving the blue sky colour, while the hardware renderers were initialising this value to zero. After doing a few hardware tests and being pointed to relevant documentation by Steveice10, GPUCode determined that using the previous stage as input in the first stage is a special case. Implementing this simple observation fixed the sky problems in Kirby's Blowout Blast, solved certain maps where the ground was not rendered in Fire Emblem Awakening and, surprisingly, brought back the missing eyebrows in Puyo Puyo Chronicle.</p><div class='image-comparison'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/kirby_before.jpg' alt='Before fix'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/kirby_after.jpg' alt='After fix'></div><p>Before</p><p>After</p><div class='image-comparison'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/puyo_before.jpg' alt='Before fix'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/puyo_after.jpg' alt='After fix'></div><p>Before</p><p>After</p><h4>Chapter 2 - The nightmares of precision</h4><p>Missing graphics can be caused by a variety of reasons, not all of which are related to the fragment stage. Precision related bugs are the bane of emulation, especially when the guest system has lower precision than the host. Case in point, the PICA is a wonderful blend of non-standard floating point types. You get 24-bit floats for most rendering operations, 20-bit floats, 16-bit floats, even a bunch of fixed point formats for miscellaneous registers. It would be strange for Citra not to exhibit at least some precision related glitches. An example is in Rune Factory 4, where lakes in dungeons will refuse to render on Citra due to depth precision differences between the host GPU and console.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/factory4.jpg' alt='Rune Factory 4 with missing water'><p>Using small workarounds, rendering can be fixed, but it's not a proper solution nor can it be integrated into upstream yet</p><p>While this specific issue is for future us to solve, there are other cases we can talk about. Picross 3D Round 2 was notorious for having missing pictures in puzzles which made it cumbersome to select levels to play. In Rabbids: Travel in Time 3D, the top screen was cut in half during the intro cinematic. The Riki Densetsu series of games also exhibited a similar problem, but with the character sprites that were cut in half when facing a specific direction. All these problems had one thing in common. And that... was clip planes. That information was known even before GPUCode decided to look into the issue, as people quickly found that most of these games were regressed by the original PR from wwylele that implemented user defined PICA clip planes.</p><p>What is happening here is that the missing 2D elements are being rendered with a z value extremely close to clip plane 0 and, thus, getting erroneously clipped by the host GPU. The 3DS GPU does not have the required precision to express these tiny depth values and they are likely rounded to zero as a result, avoiding the clipping problems.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/picross1.png' alt='Picross with missing images'><p>Am I supposed to play blindfolded?</p><p>To whom am I referring to, really?</p><p>The only entirely correct solution to this problem would be to emulate the target floating point number in software, which is the only way to perfectly match the console results. However, in practice, this is extremely impractical. Not only would the code become much more complex, but also much slower to boot. So GPUCode picked the next best option: defining a small epsilon value around clip plane zero to flush these depth values to zero, thereby avoiding the clipping. The epsilon value was selected based on the affected games and hardware experimentation.</p><p>As a side note, if you've used Citra before you've likely come across the Accurate Multiplication setting in the Emulation > Graphics > Advanced tab. If you thought that setting may be related, you are correct. The general recommendation for that is to leave it disabled unless a specific game requires it. As the helpful tooltip will also tell you, the setting exists because of differences in behaviour of floating point multiplication between your computer and the 3DS. Differences that are very expensive to account for.</p><h4>Chapter... hey, what is blending doing here?</h4><p>That's quite the interesting one... Blending is a term you've probably heard before, that refers to a commonly used technique to achieve transparency between objects. The idea is simple: take the colour of the existing background and the colour of the object being rendered, combine them with a simple arithmetic operation and write the final result to the framebuffer. This is fast and works wonders, assuming the rendered geometry has been sorted based on view distance from the camera. That might also be why blending is one of the last remaining fixed function components of fragment processing in modern GPUs. Though things do get messy when the hardware you are emulating has different blending behaviour compared to the host, as one has little control over fixed-function hardware.</p><p>This whole discussion about blending started due to an old issue Pokémon Mystery Dungeon: Gates to Infinity had, where staircases weren't turning transparent when Pokémon were interacting with them. Citra developer Subv first looked into the issue and found it was caused by an inaccurate MIN/MAX blending mode handling. The 3DS will multiply the colours with constants, called blend factors, before comparing them, which is something that desktop GPUs will not do. Achieving this behaviour with OpenGL at the time was deemed extremely hard and the case was left unclosed.</p><p>6 years later, GPUCode revisited the issue and attempted to solve it using modern tools and available extensions. For NVIDIA and AMD users, there are dedicated OpenGL extensions that allow us to change this blending behaviour, namely GL_NV_blend_minmax_factor and GL_AMD_blend_minmax_factor. Enabling these extensions is by far the easiest way to achieve the desired behaviour, however the obvious downside is that these have no support outside of their respective vendors (and outside of Windows in AMDs case), which means they will not suffice for everyone.</p><div class='image-comparison'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/pokemon_before.jpg' alt='Before fix'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/pokemon_after.jpg' alt='After fix'></div><p>Before</p><p>After</p><p>The main challenge with emulating blending is accessing the existing framebuffer colour to perform the necessary calculations with the incoming fragment colour. For Android, this is rather easy, however, where framebuffer fetches extensions for programmable blending are ubiquitous and cost very little due to the tiled architecture of mobile GPUs. For them, Citra will detect when emulation is necessary, disable the host blending, and perform the blending operations in the fragment shader with these extensions.</p><p>What about the rest of the desktop ecosystem, though? Luckily for us, Intel iGPUs support the framebuffer fetch extension, which means the system we developed for Android can effectively be reused for them as well. Reusing code is always neat-o. Lastly, for Linux users running the open source RADV driver, we can use a similar approach but instead of simply fetching the framebuffer contents from the shader, we have to attach the framebuffer as a texture and rely on ARB_texture_barrier to get defined behaviour. We hope all these methods combined will cover all platforms Citra can be used for so that everyone, regardless of their environment, can experience accurate rendering.</p><p>The results speak for themselves, Pokémon Mystery Dungeon: Gates to Infinity now renders correctly, and, surprisingly, the Shin Megami Tensei games also had their transparency during battles fixed. This is definitely a pleasant surprise, as these games are very popular and the community has been asking for a fix for a long time now. So we're happy that this endeavour coincidentally fixed this issue as well! For now, this change remains OpenGL only, with plans to also implement it for Vulkan in the future.</p><div class='image-comparison'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/shin_megami_before.jpg' alt='Before fix'><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/shin_megami_after.jpg' alt='After fix'></div><p>Before</p><p>After</p><p>Not stopping there, GPUCode delivered another graphical fix. This time for Weapon Shop de Omasse, where the intro cinematic would not display properly. Turns out, the game does not properly initialise the register used for forming the output vertex from shader registers. Turning to hardware testing, GPUCode found the default that Citra used in this case was incorrect and changing it to match the testing results fixed the rendering issues.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/weapon_shop.jpg' alt='Weapon Shop intro'><p>The one time seeing a Level 5 intro made me happy</p><p>You want more? Really? Sure then, let's travel to the magical realm of texture caching and check out some improvements or ahem..</p><h4>Chapter 3 - The final boss was the texture cache all along</h4><p>In the previous progress report, we already went into great detail about the numerous texture cache refactors that enabled exciting features, such as adding a new graphics backend. However there were yet more problems to fix as we later found. Firstly, GPUCode fixed a long-standing regression dating way back to the summer of 2022, where unaligned texture downloads would not be handled correctly. This mainly affected Metroid Prime: Federation Force, but could also affect any other game that performed unaligned texture downloads. Interestingly the game went through multiple stages of breakage, with the screen first being shifted to the right, and then shifted a little bit down, before being fixed entirely in the end. Unfortunately, it's still as slow as molasses because the texture cache cannot accelerate display transfers from fill surfaces. When that is addressed, we expect the game to run flawlessly.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/metroid_shifted.jpg' alt='Metroid shifted screen'><p>A little bit to the left...</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/metroid_shifted2.jpg' alt='Metroid shifted screen more'><p>A little bit to the top...</p><p>Secondly, and the last graphical fix we will take a look at today (we do need to leave some for the next progress report, after all), GPUCode fixed another long standing set of graphical corruptions that plagued both Pac-Man Party 3D and Tales of the Abyss. The latter seems to be a divisive remake for people, with many comparing the PS2 and 3DS versions extensively. Not like you could play either game on Citra anyway, as both screens would either be black with the hardware renderers or very misaligned in the case of the software renderer. It was obvious the bug would be anything but simple to track down. However a familiar name, Subv, first looked into these games and provided a nice starting point: both games perform strange address calculations in their display transfer routines. Armed with that information, GPUCode opened Tales of Abyss in a decompiler and set out to discover what exactly the games were doing. And, with a little effort, the offending code was found. It was triggered only when the games were using specific display transfer parameters. Pac-Man Party 3D and Tales of the Abyss both made use of those.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/tales_warped.jpg' alt='Warped Tales of Abyss screen'><p>Honey, spacetime is warping again</p><p>But the question was, \"why?\". These two games are the only ones reported to exhibit this misalignment. Were they trying to workaround hardware quirks when doing transfers with the specific parameters? As you know by now, these questions can only be answered by testing, testing, and even more testing. Luckily for us, this hypothesis proved to be correct, as the console results did not match what Citra was doing. The solution was also surprisingly straightforward: take the output address and transform it the opposite way the game does when using the same display transfer parameters. This not only fixed rendering but also emulated the broken rendering that the hardware exhibits. Fun fact, the weirdness doesn't end for the case of the Tales of the Abyss. The game also triggered a bunch of edge cases in Citra's geometry shader implementation that made it crash in the first battle. At the time of writing these edge cases have already been hardware tested and implemented, which makes the game fully playable. We'll talk about those next time around, though.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/tales_fixed.jpg' alt='Fixed Tales of Abyss'><p>Can I have a cookie too please?</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/tales_character.jpg' alt='Tales of Abyss character'><p>I bet he's excited to relive the adventure on Citra</p><h3>End of story, shader lessons learned</h3><p>While this marks the end of the graphical fixes, there are still more graphical additions to cover. With the inclusion of Apple Silicon support this year, a feat that required changes to almost every part of the codebase, Citra has expanded its arm64 support greatly. As part of that effort, regular contributor Wunkolo stepped up to make a whole new shader JIT backend targeting the ARM architecture. Both merryhime and JosJuice chimed in and provided valuable feedback, so a big thanks goes out to them as well. The new backend will be enabled by default on arm64 platforms, resulting in about double the performance on most games with hardware shaders disabled.</p><p>The benefit of improving shader JIT performance might not be immediately obvious, when hardware shaders exist and have great performance on the vast majority of devices. However, there are rare situations where hardware shaders cannot be used, causing the emulator to fallback to the software implementation as a means of maintaining accuracy. One such case is geometry shaders, which are very difficult to emulate on the host GPU due to 3DS hardware quirks. Games that make heavy use of these shaders will see a noticeable performance boost with this addition. As an example, the Monster Hunter games use geometry shaders to render the grass, leading to the slow shader interpreter having to handle all those draw calls, causing a significant slowdown. Now, these areas run at full speed with no issues!</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/monster_hunter.jpg' alt='Monster Hunter grass'><p>Perfect place for hide and seek</p><p>Wunkolo not only added a brand new shader backend, but also improved the existing x86 JIT by implementing additional optimizations using Intel AVX and AVX512 instruction sets. Processors that support these instruction sets will see a small, but noticeable, performance uplift.</p><p>They say history repeats itself... and our shader problems sure do so as well. It was well known for a while that Citra generated an excessive amount of shaders for many games. Even repetitive actions like opening a door in Luigi's Mansion Dark Moon would generate new shaders and cause stutter. The Vulkan backend helped to alleviate most of the stuttering with a clever combination of parallel shader compilation and driver queries, but the shader generation still occurred. For many mobile devices specifically, the shader cache would grow too large, causing the device to run out of memory and crash. That's a big no-no for sure.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/shader_cache.jpg' alt='Shader cache size'><p>How many thousands is that again?</p><p>It's hard to believe any game would intentionally require that many shaders. Most likely there was some shader duplication going on that made Citra do unnecessary work. What we couldn't envision was in how many areas this duplication was manifesting.</p><p>Contributor m4wx first noticed something peculiar: Citra would always take into consideration the PICA lighting state when generating fragment shaders, even when lighting was disabled completely. Changing lighting parameters shouldn't matter much when the feature is disabled, yet Citra would generate new shaders each time. By masking out parameters when their respective feature is disabled, the amount of generated shaders has been greatly reduced, without any behavioural changes.</p><p>Based on this observation by m4wx, GPUCode expanded upon it, by masking out even more unnecessary parameters, this time in the TEV shader generation. This mainly affected the title screen of The Legend of Zelda: A Link Between Worlds, which generated dozens of duplicate shaders. With that change the number of shaders being compiled was halved once more. The final change regarding shader compilation was done on the OpenGL backend. As a remnant of old OpenGL versions, Citra would specify the uniform interface for every compiled shader, even though that never practically changed. This interface describes what data the fragment shader receives from the vertex shader and what data from the CPU. Utilising ARB_explicit_uniform_location afforded by the OpenGL version upgrade to 4.3, Citra no longer has to do this, further reducing the amount of work done per shader.</p><h3>Audio</h3><p>Developer SachinVin refactored DSP interrupt handling, which makes the implementation easier to use and unit test.</p><p>Steveice10 also landed a bunch of audio improvements, one of which specifically benefits Android users. Since Android phones often vary in performance, Citra employs a dynamic approach to audio stretching on said platform, where it is automatically enabled or disabled depending on whether the game is running at full speed or not. This ensures that no jarring audio cut-offs occur during gameplay. However, many users noted that audio stretching noticeably lowered the final audio quality and would exhibit strange speedups and slowdowns at random times.</p><p>To make a long story short, when the time stretcher is turned off, audio samples would be flushed from it into the output before proceeding with regular audio. If the amount of audio in the stretcher was too large for the output buffer, Citra would leave sample data behind in the stretcher. Then, when the stretcher is enabled again, the leftover audio from the past would be played, leading to a desync in audio playback. To solve this, Steveice10 ensured that the time stretcher clears the remaining data after flushing to the output as much as possible.</p><p>A significant rework was also done to the AAC decoder infrastructure by the same developer. Because the AAC codec used by 3DS games was patented, Citra could not bundle a library to decode it. Rather, it needed to rely on the host operating system facilities, which can vary widely on quality and features. For example, the Windows WMF AAC decoder is riddled with bugs from having too low volume, producing incorrect audio waveforms and, more relevant for us, causing audio desync in rhythm games such as Rhythm Heaven Megamix.</p><p>As it turns out though, the patent for AAC-LC, the codec used by the 3DS specifically, has been considered expired for many years. Other groups like Fedora's legal team and Flatpak maintainers have also concluded that the patents for AAC-LC have expired and can be considered free for use. With this information, Steveice10 stripped out the various AAC decoder implementations and replaced them with one universal bundled decoder, trimmed down to include only the relevant codec. This makes Citra's support of AAC no longer require on specific external dependencies, like in the case of Linux. It also makes it consistent across different platforms instead of having varying latency and quality depending on the supported backend. Further work on improving AAC support can be performed on this one backend for all platforms as needed.</p><img src='https://azahar-emu.org/resources/blogs/one-year-citra-takedown/rhythm_heaven.jpg' alt='Rhythm Heaven gameplay'><p>The beat is addicting... your writer needs a little practise though</p><p>That said, our HLE audio emulation is not perfect. For example, Virtual Console games have distorted or no audio at all, some other games have missing audio as well. To combat this, we have begun efforts to improve the performance of our LLE audio backend so it can serve as a viable alternative for those problematic cases. Developer SachinVin has started work on a Ghidra plugin for the Teak architecture, which is used by the 3DS DSP. This will allow us to more easily understand the inner workings of the firmware used to drive the DSP. With the aid of this tool, GPUCode wrote a prototype JIT compiler for the DSP. Early tests have shown an impressive 2x performance boost over the reference interpreter. We will probably have more to say on the matter in a few months time.</p><h3>Conclusion</h3><p>Anddd finally, we're done. Another year, another amazing set of changes that brings us ever closer to fully capturing the experience of using this wonderful handheld console. Development has been progressing at lightning speeds this past year and into 2024, which we are very proud of and gives us more interesting content to talk about in progress reports. Same as before, big props to the Citra community, the developers, and all the people that keep the project alive and well!</p><p>As a final word, I'd like to thank everyone who has supported us so far. Compared to where we were a year ago, the current scene of 3DS emulation is buzzing with activity, and the future has never been more exciting. Those of you who wish to help Azahar at this early stage of its life can already do so by visiting the GitHub page as the source code has recently been made available. Let's celebrate the time of Citra and look forward to the progress that will be made in this revitalized 3DS emulation scene in the years to come. As always, I hope you look forward to the next blog post.</p>"
      },
      {
        "id": 3,
        "title": "Fake Websites: A Word of Caution",
        "date": "March 2, 2025",
        "excerpt": "Better safe than sorry.",
        "category": "news",
        "author": {
          "name": "OpenSauce",
          "avatar": "https://avatars.githubusercontent.com/u/48618519?v=4"
        },
        "image": "news.png",
        "content": "<p>In this short blog post, I'd like to focus on our presence on the internet.</p><p>In particular, I'd like to emphasize that this website, azahar-emu.org, is our only website. Any other websites you may see claiming to be us have no association to us and may be malicious.</p><p>In particular, one site with the url \"azahar-emulator.org\" currently appears above ours in some search engines/ regions. This website has a very similar appearance to the official site, and claims to be operated by \"Azahar Emulator Staff\" in some sections while implying that it is unofficial in others. We do not know who is operating this site, and would recommend avoiding it along with any other sites which may impersonate the official site.</p><p>When Azahar releases, these sites may take advantage of the spike of interest and upload malicious versions of the emulator to the website, which may be downloaded by unsuspecting users who clicked on the first search result they saw. It's impossible to know the intentions of these sites, so it is best to avoid them in case something like this happens.</p><p>If the author of the aforementioned unofficial site is reading this and made it with good intentions, I invite you to reach out to us so we can discuss it.</p><p>Be careful, and we hope you look forward to future news about the Azahar emulator.</p>"
      },
      {
        "id": 4,
        "title": "Azahar Emulator Repository Goes Public",
        "date": "February 27, 2025",
        "excerpt": "The beginning of a collaborative future.",
        "category": "news",
        "author": {
          "name": "OpenSauce",
          "avatar": "https://avatars.githubusercontent.com/u/48618519?v=4"
        },
        "image": "news.png",
        "content": "<p>Hello again! It has been a while since we announced the Azahar emulator project, and today we are proud to announce that after working on the project for a while in the background, it is now time for the code of the upcoming emulator to go public.</p><p>You can find the code at https://github.com/azahar-emu/azahar</p><h2>What does this mean?</h2><p>It's important to emphasize that the emulator does not yet have a stable release. This announcement only refers to the code for the emulator becoming available to the public. From this point, work will continue towards our first stable release, but from now it will be done in the open.</p><p>Starting from now, eager developers who wish to begin contributing to the project can start opening pull requests, and any pull requests brought over from Lime3DS will be re-opened and rebased by a maintainer in the coming weeks. It is not our goal to include any non-critical pull requests in the first release, and this will instead be deferred to future releases.</p><h2>Can I use the emulator yet?</h2><p>It is currently not recommended to use the emulator unless you are a developer or an early adopter who understands that the emulator isn't yet in a polished state but wants to give it a try anyway. If you use the emulator now, you will likely experience issues which will have been ironed out by the time the emulator has a stable release. Here be dragons.</p><p>Once our first release has been produced (which hopefully shouldn't take too long from now), the project will be considered ready for general use and can be considered a drop-in replacement for PabloMK7's Citra fork or Lime3DS.</p><p>I hope everyone continues to look forward to the future development of the Azahar emulator project and its first stable release.</p>"
      },
      {
        "id": 5,
        "title": "Game Loading on Azahar: What's Changing",
        "date": "December 12, 2024",
        "excerpt": "Everything you need to know about game loading changes and why they matter.",
        "category": "technical",
        "author": {
          "name": "PabloMK7",
          "avatar": "https://avatars.githubusercontent.com/u/10946643?v=4"
        },
        "image": "news.png",
        "content": "<p>The legality of emulation has been a subject of debate since the early days. In 1999 Sony sued Bleem!, a PlayStation Emulator, which started a legal battle that ultimately ruled in favor of emulation. While Bleem! had to eventually close due to bankruptcy, they set a very imporant precedent in favor of videogame preservation through emulation.</p><p>However as technology advances, emulation faces new legal challenges, particularly regarding technological protection measures (TPM) on modern consoles like on the 3DS. In fact, the circumvention of TPM done by the Switch emulator Yuzu became the central argument in Nintendo's lawsuit against Tropic Haze, the company behind the now defuct emulators Yuzu and Citra.</p><p>We have taken this lawsuit very seriously, and have decided to introduce some design changes in Azahar to address some potential concerns.</p><p>Before starting I would like to make it clear that we strongly believe Azahar and formerly Citra were in the clear even before making these design changes, and we are simply trying to make things as clear as possible to prevent any potential confusion we hadn't considered. Please keep in mind that all the decisions explained below have been taken after doing an interpretation of Spanish intellectual property law, as this is where I am based.</p><h2>Decision #1: Removing encrypted game support</h2><p>In order to not cause any confusion regarding Azahar's goals, we have taken the decision to limit the circumvention of TPM as much as we posibly can. Circumvention will only be performed whenever interoperability of Nintendo's code is required with Azahar or with other Nintendo's code. As a result Azahar will not allow launching or installing encrypted games, unless they have been obtained through Nintendo's official applications, such as the eShop or System Settings.</p><h2>Decision #2: Bundling cryptographic keys</h2><p>Citra required users to extract cryptographic keys to be able to run encrypted games. This was mostly done for two separate reasons:</p><ol><li>To prove that in order to use encrypted games on Citra, you had to own a console. However, the extraction process was complex and eventually lead to the users just downloading the keys from the internet.</li><li>To justify that Citra did not perform the circumvention of TPM by itself, as users had to provide the cryptographic keys themselves. However, this does not change the fact that the circumvention is ultimately being done by the emulator, and the user being involved in this process is irrelevant.</li></ol><p>Since those reasons do not really play a role to the legality of the emulator, we have switched our focus to other aspects of the law, such as interoperability, accessibility and private copy. To make things easier to everyone, we will directly include the cryptographic keys in Azahar. That way, users will no longer need to extract them from their consoles.</p><p>Keep in mind that cryptographic keys are just very big numbers, which are generated randomly. Therefore they are not creative enough to be protected by copyright law. Furthermore, most of the keys are used to perform cryptographic operations on chunks of data that are not copyrighted works, as they again are not creative enough to be protected (mii and amiibo information, online packets, structures of numbers, etc). Additionally, we are far from the only emulator doing such a thing:</p><ul><li>PPSSPP</li><li>RPCS3</li><li>DeSmuME</li><li>Vita3K</li><li>melonDS</li><li>Cemu</li></ul><h2>Decision #3: Distancing from piracy terms</h2><p>Azahar developers are against piracy, which puts emulation development and game preservation at high risk. For that reason we want to distance from piracy terminology as much as possible, so we will be dropping support for the .3ds file extension which had its roots in piracy tools. Instead we will add support for the .cci file extension, which is the official name for cartridge images.</p><h2>Decision #4: Not providing game copying guides</h2><p>Since every jurisdiction is different, we leave it to users to determine the proper and lawful method for obtaining private copies of their own games. Azahar will focus instead on providing guides for setting up the emulator, installing the firmware and accessing the eShop, enabling users to re-download owned titles from there.</p><h2>Final words</h2><p>I would like to conclude this article by highlighting a few alternative use cases for Azahar beyond playing private copies of your games, supported by documented evidence of their usefulness:</p><ul><li>Obtaining and playing original copies of your owned games by re-downloading them from the eShop.</li><li>Preserving the history of videogames, which would otherwise be lost once the original consoles stop working.</li><li>Improving accessibility for users with disabilities or impedements that have a hard time enjoying their games on real hardware.</li><li>Reducing e-waste by allowing users to continue using partially broken consoles to play their games (using Artic Base for example), instead of having to dispose of them.</li><li>Allowing users to access discontinued online features of the games they have bought by using third party services such as Pretendo Network.</li><li>Developing and using homebrew applications created by people \"at home\" without using Nintendo's official tools or processes.</li><li>Research and education, including courses about game development on embedded systems (which, fun fact, I actualy took a course on this myself, which is what got me into Citra development!)</li></ul><p>Additionally, we are pleased to report that we have received written authorization from at least one video game developer, explicitly granting permission for their games to be emulated on Azahar, and we will be seeking support from more!</p><p>Finally, I would like to remind all readers to please act responsably when it comes to piracy. Not only you are damaging video game studios when unjustified mass piracy happens, you are also putting videogame preservation projects (such as Azahar) at risk of being terminated. Please consider these repurcussions before you act. Thank you.</p>"
      },
      {
        "id": 6,
        "title": "A New Beginning",
        "date": "December 8, 2024",
        "excerpt": "How we got here, where we are, and where we're going.",
        "category": "news",
        "author": {
          "name": "OpenSauce",
          "avatar": "https://avatars.githubusercontent.com/u/48618519?v=4"
        },
        "image": "news.png",
        "content": "<p>Hello everyone!</p><p>This is the first post for what will be the primary source of news for the Azahar emulator project going forward: the Azahar Emulator Blog.</p><p>To start off this blog, I want to talk about how the Azahar emulator project came to be, where we are at the moment, and what our plans are for the future.</p><h2>Past: The death of Citra</h2><p>On the fateful day of March 4th 2024, Tropic Haze ended their support of the Citra emulator project. For many this brought feelings of disappointment, but some netizens felt that they wanted to act to preserve the legacy of this software. Several forks of Citra appeared during the time after this, the most relevant to this blog post being Lime3DS and PabloMK7's Citra fork.</p><p>These two forks continued where Citra left off, and although both had the goal of maintaining and improving upon the base Citra left behind, over time these projects gained distinct identities with differing priorities when it comes to development. While both forks occasionally shared a commit here and there, their leaderships were entirely separated.</p><h3>Lime3DS</h3><p>The motley crew of Lime3DS contributors, while determined to do their best to continue work on Citra, hadn't worked with the project's codebase before and had minimal experience with emulator development. This made technical improvements to the emulation core challenging, so a different approach to progress was taken.</p><p>The majority of the work that went into Lime3DS focused on adding new features to the emulator to improve the user experience and enhance customization possibilities, such as custom screen layouts, the ability to change the size of on-screen buttons, and haptic feedback on Android to name a few.</p><p>In addition to new features, work was also put in to fix several smaller kinks left behind in Citra's final state, with the Android version being especially notable for having several strange issues due to its at-the-time recent rewrite in Kotlin which never had the time to be fully polished.</p><h3>PabloMK7</h3><p>By contrast, PabloMK7 had already worked on the Citra emulator for a while before Citra was discontinued, so he was more than qualified to focus on developing the core of the emulator and making low-level improvements. However, this fork didn't implement any improvements and fixes to the user interface, so it was kept in mostly the same state Citra left it.</p><p>A very notable addition to this fork was that of Artic Base, a 3DS homebrew application which allows game and save file data to be broadcasted directly from the console itself over a local network connection, entirely bypassing the need to manually dump titles from the console. This innovation was a major step forward for 3DS emulation, essentially allowing the 3DS console to be used as a hub from which games are broadcasted to a computer or played on the go, similar to the Switch's model of portability.</p><h2>Present: Coming together</h2><p>After a good few months of this separate work, discussion began between PabloMK7 and I to join our efforts and create a single, unified project to continue Citra's development. After a bit of discussion, we eventually figured out what we wanted to do. Names were conceived, logos were designed, and eventually we got to the current Azahar branding.</p><p>We then began work on actually merging the codebases of the two forks. While the majority of changes between both of the forks have been preserved, some minor problematic changes have been axed, but these omissions are very minor and should not be noticed by the average user.</p><p>Additionally, as those of you who have been following PabloMK7's X profile may be aware, Azahar will also be releasing with several new features that weren't present in either of the merging forks. These include eShop support, making it possible to download demos and games which were purchased before the eShop shutdown earlier this year, alongside a new performance hack which can provide a considerable performance improvement when used with certain games on some devices.</p><h2>Future: What comes next?</h2><p>Looking forward, we want to continue developing the emulator as we had been in our own forks over the last 8 months. Now that Citra development has been condensed into a single project instead of being fragmented between two major forks, we hope this will serve as a stable platform for future development and provide a unified community for users and developers alike to engage with and enjoy.</p><p>We will continue sharing information to this blog as time passes, and we hope that you are as excited as we are to turn this new page on 3DS emulation.</p>"
      }
    ]
  }